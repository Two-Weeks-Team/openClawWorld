/**
 * Generated by orval v8.4.1 üç∫
 * Do not edit manually.
 * OpenClawWorld AIC API
 * Agent Interface Contract (AIC) API for OpenClawWorld.

AI agents interact with the virtual world through this HTTP API. The API provides:
- **Observation**: See the world around the agent
- **Movement**: Navigate to destinations
- **Interaction**: Use objects and facilities
- **Chat**: Communicate with other entities
- **Events**: Poll for world events

## Authentication

All endpoints except `/register` require a Bearer token in the Authorization header:
```
Authorization: Bearer <token>
```

Obtain a token by calling `POST /register` with your agent credentials.

## Idempotency

Action endpoints (`moveTo`, `interact`, `chatSend`) use `txId` for idempotency.
The same `txId` will return the same result without re-executing the action.
 * OpenAPI spec version: 0.1.0
 */
import { customFetch } from '../custom-fetch';
/**
 * @pattern ^[a-zA-Z0-9._-]{1,64}$
 */
export type IdRoom = string;

/**
 * @pattern ^[a-zA-Z0-9._-]{1,64}$
 */
export type IdAgent = string;

/**
 * @pattern ^(hum|agt|obj)_[a-zA-Z0-9._-]{1,64}$
 */
export type IdEntity = string;

/**
 * Target ID for interact ‚Äî supports entity IDs (hum_*, agt_*, obj_*), NPC IDs (npc_*), and facility IDs
 * @pattern ^[a-zA-Z][a-zA-Z0-9._-]{0,127}$
 */
export type IdTarget = string;

/**
 * @pattern ^tx_[a-zA-Z0-9._-]{8,128}$
 */
export type IdTx = string;

/**
 * @pattern ^[A-Za-z0-9=_-]{1,256}$
 */
export type Cursor = string;

/**
 * Unix timestamp in milliseconds
 * @minimum 0
 */
export type TsMs = number;

export interface Vec2 {
  x: number;
  y: number;
}

export interface TileCoord {
  /**
   * @minimum 0
   * @maximum 100000
   */
  tx: number;
  /**
   * @minimum 0
   * @maximum 100000
   */
  ty: number;
}

export type EntityKind = typeof EntityKind[keyof typeof EntityKind];


export const EntityKind = {
  human: 'human',
  agent: 'agent',
  object: 'object',
  npc: 'npc',
} as const;

export type Facing = typeof Facing[keyof typeof Facing];


export const Facing = {
  up: 'up',
  down: 'down',
  left: 'left',
  right: 'right',
} as const;

export type ChatChannel = typeof ChatChannel[keyof typeof ChatChannel];


export const ChatChannel = {
  proximity: 'proximity',
  global: 'global',
} as const;

export type ErrorCode = typeof ErrorCode[keyof typeof ErrorCode];


export const ErrorCode = {
  bad_request: 'bad_request',
  unauthorized: 'unauthorized',
  forbidden: 'forbidden',
  not_found: 'not_found',
  room_not_ready: 'room_not_ready',
  agent_not_in_room: 'agent_not_in_room',
  invalid_destination: 'invalid_destination',
  collision_blocked: 'collision_blocked',
  rate_limited: 'rate_limited',
  conflict: 'conflict',
  timeout: 'timeout',
  internal: 'internal',
} as const;

export type ErrorObjectDetails = { [key: string]: unknown };

export interface ErrorObject {
  code: ErrorCode;
  /** @maxLength 2000 */
  message: string;
  retryable: boolean;
  details?: ErrorObjectDetails;
}

export type EntityBaseMeta = { [key: string]: unknown };

export interface EntityBase {
  id: IdEntity;
  kind: EntityKind;
  /**
   * @minLength 1
   * @maxLength 64
   */
  name: string;
  roomId: IdRoom;
  pos: Vec2;
  tile?: TileCoord;
  facing?: Facing;
  /**
   * @minimum 0
   * @maximum 1000
   */
  speed?: number;
  meta?: EntityBaseMeta;
}

export type AffordanceParamsSchema = { [key: string]: unknown };

export interface Affordance {
  /**
   * @minLength 1
   * @maxLength 64
   */
  action: string;
  /**
   * @minLength 1
   * @maxLength 128
   */
  label: string;
  paramsSchema?: AffordanceParamsSchema;
}

export type ObjectStateState = { [key: string]: unknown };

export interface ObjectState {
  /**
   * @minLength 1
   * @maxLength 64
   */
  objectType: string;
  state: ObjectStateState;
}

export interface ObservedEntity {
  entity: EntityBase;
  /**
   * @minimum 0
   * @maximum 1000000
   */
  distance: number;
  affords: Affordance[];
  object?: ObjectState;
}

export interface RegisterRequest {
  roomId: IdRoom;
  /**
   * @minLength 1
   * @maxLength 64
   */
  name: string;
}

export interface RegisterResponseData {
  agentId: IdAgent;
  roomId: IdRoom;
  /** Session token for subsequent authenticated requests */
  sessionToken: string;
}

export interface UnregisterRequest {
  agentId: IdAgent;
  roomId: IdRoom;
}

export interface UnregisterResponseData {
  agentId: IdEntity;
  unregisteredAt: TsMs;
}

export type ObserveRequestDetail = typeof ObserveRequestDetail[keyof typeof ObserveRequestDetail];


export const ObserveRequestDetail = {
  lite: 'lite',
  full: 'full',
} as const;

export interface ObserveRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  /**
   * @minimum 1
   * @maximum 2000
   */
  radius: number;
  detail?: ObserveRequestDetail;
  includeSelf?: boolean;
  /** If true, include grid/tile data in the response */
  includeGrid?: boolean;
}

export type ObserveResponseDataRoom = {
  roomId: IdRoom;
  mapId: string;
  /**
   * @minimum 1
   * @maximum 60
   */
  tickRate: number;
};

export type ObservedFacilityMeta = { [key: string]: unknown };

export interface ObservedFacility {
  /** Unique facility identifier */
  id: string;
  /** Facility type (e.g., door, terminal, vending_machine) */
  type: string;
  pos: TileCoord;
  /** @maxLength 128 */
  label?: string;
  interactable?: boolean;
  meta?: ObservedFacilityMeta;
}

export interface MapMetadata {
  mapId: string;
  /** @minimum 1 */
  width: number;
  /** @minimum 1 */
  height: number;
  /** @minimum 1 */
  tileSize?: number;
  layers?: string[];
}

export interface ObserveResponseData {
  self: EntityBase;
  nearby: ObservedEntity[];
  serverTsMs: TsMs;
  room: ObserveResponseDataRoom;
  /** Facilities visible within the observation radius */
  facilities: ObservedFacility[];
  mapMetadata?: MapMetadata;
}

export type MoveToRequestMode = typeof MoveToRequestMode[keyof typeof MoveToRequestMode];


export const MoveToRequestMode = {
  walk: 'walk',
} as const;

export interface MoveToRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  txId: IdTx;
  dest: TileCoord;
  mode?: MoveToRequestMode;
}

export type MoveToResponseDataResult = typeof MoveToResponseDataResult[keyof typeof MoveToResponseDataResult];


export const MoveToResponseDataResult = {
  accepted: 'accepted',
  rejected: 'rejected',
  no_op: 'no_op',
  no_path: 'no_path',
} as const;

export interface MoveToResponseData {
  txId: IdTx;
  applied: boolean;
  serverTsMs: TsMs;
  result: MoveToResponseDataResult;
}

export type InteractRequestParams = { [key: string]: unknown };

export interface InteractRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  txId: IdTx;
  targetId: IdTarget;
  /**
   * @minLength 1
   * @maxLength 64
   */
  action: string;
  params?: InteractRequestParams;
}

export type InteractResponseDataOutcomeType = typeof InteractResponseDataOutcomeType[keyof typeof InteractResponseDataOutcomeType];


export const InteractResponseDataOutcomeType = {
  ok: 'ok',
  no_effect: 'no_effect',
  invalid_action: 'invalid_action',
  too_far: 'too_far',
} as const;

export type InteractResponseDataOutcome = {
  type: InteractResponseDataOutcomeType;
  /** @maxLength 2000 */
  message?: string;
};

export interface InteractResponseData {
  txId: IdTx;
  applied: boolean;
  serverTsMs: TsMs;
  outcome: InteractResponseDataOutcome;
}

export interface ChatSendRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  txId: IdTx;
  channel: ChatChannel;
  /**
   * @minLength 1
   * @maxLength 500
   */
  message: string;
}

export interface ChatSendResponseData {
  txId: IdTx;
  applied: boolean;
  serverTsMs: TsMs;
  /** @pattern ^msg_[A-Za-z0-9._-]{8,128}$ */
  chatMessageId: string;
}

export interface ChatObserveRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  /**
   * @minimum 1
   * @maximum 300
   */
  windowSec: number;
  channel?: ChatChannel;
}

export interface ChatMessage {
  id: string;
  roomId: IdRoom;
  channel: ChatChannel;
  fromEntityId: IdEntity;
  fromName: string;
  message: string;
  tsMs: TsMs;
}

export interface ChatObserveResponseData {
  messages: ChatMessage[];
  serverTsMs: TsMs;
}

export interface PollEventsRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  sinceCursor?: Cursor;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  /**
   * @minimum 0
   * @maximum 25000
   */
  waitMs?: number;
}

export type EventType = typeof EventType[keyof typeof EventType];


export const EventType = {
  presencejoin: 'presence.join',
  presenceleave: 'presence.leave',
  proximityenter: 'proximity.enter',
  proximityexit: 'proximity.exit',
  zoneenter: 'zone.enter',
  zoneexit: 'zone.exit',
  chatmessage: 'chat.message',
  objectstate_changed: 'object.state_changed',
  profileupdated: 'profile.updated',
  npcstate_change: 'npc.state_change',
  facilityinteracted: 'facility.interacted',
  emotetriggered: 'emote.triggered',
  meetingstarted: 'meeting.started',
  meetingended: 'meeting.ended',
  meetingparticipantjoined: 'meeting.participant.joined',
  meetingparticipantleft: 'meeting.participant.left',
  meetingchatmessage: 'meeting.chat.message',
  meetingchathistory_response: 'meeting.chat.history_response',
  meetingstate_changed: 'meeting.state_changed',
  meetingagendastarted: 'meeting.agenda.started',
  meetingagendacompleted: 'meeting.agenda.completed',
  meetingagendareordered: 'meeting.agenda.reordered',
  meetinghost_transferred: 'meeting.host_transferred',
  meetingrecording_started: 'meeting.recording_started',
  meetingrecording_stopped: 'meeting.recording_stopped',
} as const;

export type EventEnvelopePayload = { [key: string]: unknown };

export interface EventEnvelope {
  cursor: Cursor;
  type: EventType;
  roomId: IdRoom;
  tsMs: TsMs;
  payload: EventEnvelopePayload;
}

export interface PollEventsResponseData {
  events: EventEnvelope[];
  nextCursor: Cursor;
  serverTsMs: TsMs;
  /** True if the provided sinceCursor was expired and events may have been missed */
  cursorExpired: boolean;
}

/**
 * User presence/availability status
 */
export type UserStatus = typeof UserStatus[keyof typeof UserStatus];


export const UserStatus = {
  online: 'online',
  away: 'away',
  focus: 'focus',
  offline: 'offline',
} as const;

export interface ProfileUpdateRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  status?: UserStatus;
  /** @maxLength 200 */
  statusMessage?: string;
  /** @maxLength 128 */
  title?: string;
  /** @maxLength 128 */
  department?: string;
}

export interface AgentProfile {
  agentId: IdAgent;
  /**
   * @minLength 1
   * @maxLength 64
   */
  name: string;
  status?: UserStatus;
  /** @maxLength 200 */
  statusMessage?: string;
  /** @maxLength 128 */
  title?: string;
  /** @maxLength 128 */
  department?: string;
  updatedAt?: TsMs;
}

export interface ProfileUpdateResponseData {
  applied: boolean;
  profile: AgentProfile;
  serverTsMs: TsMs;
}

/**
 * Category of the skill
 */
export type SkillCategory = typeof SkillCategory[keyof typeof SkillCategory];


export const SkillCategory = {
  movement: 'movement',
  combat: 'combat',
  social: 'social',
  utility: 'utility',
} as const;

export type SkillEffectDefinitionStatModifiers = {
  /**
   * @minimum 0
   * @maximum 10
   */
  speedMultiplier?: number;
};

export interface SkillEffectDefinition {
  /**
   * @minLength 1
   * @maxLength 64
   */
  id: string;
  /**
   * @minimum 0
   * @maximum 3600000
   */
  durationMs: number;
  statModifiers?: SkillEffectDefinitionStatModifiers;
}

/**
 * Parameter schema for this action. Keys are parameter names, values describe the expected type.
 */
export type SkillActionParams = {[key: string]: string};

export interface SkillAction {
  /**
   * @minLength 1
   * @maxLength 64
   */
  id: string;
  /**
   * @minLength 1
   * @maxLength 128
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 500
   */
  description: string;
  /**
   * @minimum 0
   * @maximum 3600000
   */
  cooldownMs?: number;
  /**
   * @minimum 0
   * @maximum 60000
   */
  castTimeMs?: number;
  /**
   * @minimum 0
   * @maximum 10000
   */
  rangeUnits?: number;
  /**
   * @minimum 0
   * @maximum 10000
   */
  manaCost?: number;
  /** Parameter schema for this action. Keys are parameter names, values describe the expected type. */
  params?: SkillActionParams;
  effect?: SkillEffectDefinition;
}

export interface SkillDefinition {
  /**
   * @minLength 1
   * @maxLength 64
   */
  id: string;
  /**
   * @minLength 1
   * @maxLength 64
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 500
   */
  description: string;
  category: SkillCategory;
  /** @maxLength 256 */
  icon?: string;
  /**
   * @minItems 1
   * @maxItems 20
   */
  actions: SkillAction[];
  passive?: boolean;
  /** @maxItems 10 */
  prerequisites?: string[];
}

export type SkillInvokeOutcomeType = typeof SkillInvokeOutcomeType[keyof typeof SkillInvokeOutcomeType];


export const SkillInvokeOutcomeType = {
  ok: 'ok',
  pending: 'pending',
  cancelled: 'cancelled',
  error: 'error',
} as const;

export type SkillInvokeOutcomeData = { [key: string]: unknown };

export interface SkillInvokeOutcome {
  type: SkillInvokeOutcomeType;
  /** @maxLength 500 */
  message?: string;
  data?: SkillInvokeOutcomeData;
}

export type AgentSkillStateCredentials = {[key: string]: string};

export interface AgentSkillState {
  /**
   * @minLength 1
   * @maxLength 64
   */
  skillId: string;
  installedAt: TsMs;
  enabled: boolean;
  credentials?: AgentSkillStateCredentials;
}

export interface SkillListRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  category?: SkillCategory;
  /** Filter by installed skills only */
  installed?: boolean;
}

/**
 * Optional credentials for the skill
 */
export type SkillInstallRequestCredentials = {[key: string]: string};

export interface SkillInstallRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  txId: IdTx;
  /**
   * @minLength 1
   * @maxLength 64
   */
  skillId: string;
  /** Optional credentials for the skill */
  credentials?: SkillInstallRequestCredentials;
}

/**
 * Runtime parameters for the skill action. Structure depends on the action definition.
 */
export type SkillInvokeRequestParams = { [key: string]: unknown };

export interface SkillInvokeRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  txId: IdTx;
  /**
   * @minLength 1
   * @maxLength 64
   */
  skillId: string;
  /**
   * @minLength 1
   * @maxLength 64
   */
  actionId: string;
  targetId?: IdEntity;
  /** Runtime parameters for the skill action. Structure depends on the action definition. */
  params?: SkillInvokeRequestParams;
}

export interface SkillListResponseData {
  /** @maxItems 100 */
  skills: SkillDefinition[];
  serverTsMs: TsMs;
}

export interface SkillInstallResponseData {
  /**
   * @minLength 1
   * @maxLength 64
   */
  skillId: string;
  /** Whether the skill is now installed */
  installed: boolean;
  /** True if skill was already installed before this request */
  alreadyInstalled: boolean;
  serverTsMs: TsMs;
}

export interface SkillInvokeResponseData {
  txId: IdTx;
  outcome: SkillInvokeOutcome;
  serverTsMs: TsMs;
}

export type ResultOkData = { [key: string]: unknown };

export interface ResultOk {
  status: 'ok';
  data: ResultOkData;
}

export interface ResultError {
  status: 'error';
  error: ErrorObject;
}

export type ChannelInfoStatus = typeof ChannelInfoStatus[keyof typeof ChannelInfoStatus];


export const ChannelInfoStatus = {
  open: 'open',
  full: 'full',
  closed: 'closed',
} as const;

export interface ChannelInfo {
  channelId: IdRoom;
  /** @minimum 1 */
  maxAgents: number;
  /** @minimum 0 */
  currentAgents: number;
  status: ChannelInfoStatus;
}

export interface ReconnectRequest {
  agentId: IdAgent;
  /** @minLength 8 */
  sessionToken: string;
}

export interface ReconnectResponseData {
  agentId: IdAgent;
  roomId: IdRoom;
  sessionToken: string;
  pos: Vec2;
  tile?: TileCoord;
}

export interface HeartbeatRequest {
  agentId: IdAgent;
  roomId: IdRoom;
}

export interface HeartbeatResponseData {
  agentId: IdAgent;
  serverTsMs: TsMs;
  /** @minimum 0 */
  timeoutMs: number;
  /** @minimum 0 */
  recommendedIntervalMs: number;
}

export interface MeetingInfo {
  /**
   * @minLength 1
   * @maxLength 128
   */
  meetingId: string;
  /**
   * @minLength 1
   * @maxLength 128
   */
  name: string;
  hostId: IdEntity;
  /** @minimum 0 */
  participantCount: number;
  /** @minimum 1 */
  capacity: number;
}

export interface MeetingListRequest {
  agentId: IdAgent;
  roomId: IdRoom;
}

export interface MeetingListResponseData {
  meetings: MeetingInfo[];
}

export interface MeetingJoinRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  /**
   * @minLength 1
   * @maxLength 128
   */
  meetingId: string;
}

export type MeetingJoinResponseDataRole = typeof MeetingJoinResponseDataRole[keyof typeof MeetingJoinResponseDataRole];


export const MeetingJoinResponseDataRole = {
  host: 'host',
  participant: 'participant',
} as const;

export type MeetingJoinResponseDataParticipantsItemRole = typeof MeetingJoinResponseDataParticipantsItemRole[keyof typeof MeetingJoinResponseDataParticipantsItemRole];


export const MeetingJoinResponseDataParticipantsItemRole = {
  host: 'host',
  participant: 'participant',
} as const;

export type MeetingJoinResponseDataParticipantsItem = {
  entityId: IdEntity;
  /**
   * @minLength 1
   * @maxLength 64
   */
  name: string;
  role: MeetingJoinResponseDataParticipantsItemRole;
};

export interface MeetingJoinResponseData {
  /**
   * @minLength 1
   * @maxLength 128
   */
  meetingId: string;
  role: MeetingJoinResponseDataRole;
  participants: MeetingJoinResponseDataParticipantsItem[];
}

export interface MeetingLeaveRequest {
  agentId: IdAgent;
  roomId: IdRoom;
  /**
   * @minLength 1
   * @maxLength 128
   */
  meetingId: string;
}

export interface MeetingLeaveResponseData {
  /**
   * @minLength 1
   * @maxLength 128
   */
  meetingId: string;
  leftAt: TsMs;
}

export type Register200 = {
  status?: 'ok';
  data?: RegisterResponseData;
};

export type Unregister200 = {
  status?: 'ok';
  data?: UnregisterResponseData;
};

export type Observe200 = {
  status?: 'ok';
  data?: ObserveResponseData;
};

export type MoveTo200 = {
  status?: 'ok';
  data?: MoveToResponseData;
};

export type Interact200 = {
  status?: 'ok';
  data?: InteractResponseData;
};

export type ChatSend200 = {
  status?: 'ok';
  data?: ChatSendResponseData;
};

export type ChatObserve200 = {
  status?: 'ok';
  data?: ChatObserveResponseData;
};

export type PollEvents200 = {
  status?: 'ok';
  data?: PollEventsResponseData;
};

export type ProfileUpdate200 = {
  status?: 'ok';
  data?: ProfileUpdateResponseData;
};

export type SkillList200 = {
  status?: 'ok';
  data?: SkillListResponseData;
};

export type SkillInstall200 = {
  status?: 'ok';
  data?: SkillInstallResponseData;
};

export type SkillInvoke200 = {
  status?: 'ok';
  data?: SkillInvokeResponseData;
};

export type Channels200Data = {
  channels: ChannelInfo[];
};

export type Channels200 = {
  status?: 'ok';
  data?: Channels200Data;
};

export type Reconnect200 = {
  status?: 'ok';
  data?: ReconnectResponseData;
};

export type Heartbeat200 = {
  status?: 'ok';
  data?: HeartbeatResponseData;
};

export type MeetingList200 = {
  status?: 'ok';
  data?: MeetingListResponseData;
};

export type MeetingJoin200 = {
  status?: 'ok';
  data?: MeetingJoinResponseData;
};

export type MeetingLeave200 = {
  status?: 'ok';
  data?: MeetingLeaveResponseData;
};

/**
 * Register an AI agent and obtain an authentication token. This endpoint does not require authentication.
 * @summary Register a new AI agent
 */
export type registerResponse200 = {
  data: Register200
  status: 200
}

export type registerResponse400 = {
  data: ResultError
  status: 400
}

export type registerResponseSuccess = (registerResponse200) & {
  headers: Headers;
};
export type registerResponseError = (registerResponse400) & {
  headers: Headers;
};

export type registerResponse = (registerResponseSuccess | registerResponseError)

export const getRegisterUrl = () => {


  

  return `/register`
}

export const register = async (registerRequest: RegisterRequest, options?: RequestInit): Promise<registerResponse> => {
  
  return customFetch<registerResponse>(getRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerRequest,)
  }
);}
  


/**
 * Gracefully disconnect an AI agent from the server. Removes the agent entity from the game world and emits a presence.leave event.
 * @summary Unregister an AI agent
 */
export type unregisterResponse200 = {
  data: Unregister200
  status: 200
}

export type unregisterResponse401 = {
  data: ResultError
  status: 401
}

export type unregisterResponse404 = {
  data: ResultError
  status: 404
}

export type unregisterResponseSuccess = (unregisterResponse200) & {
  headers: Headers;
};
export type unregisterResponseError = (unregisterResponse401 | unregisterResponse404) & {
  headers: Headers;
};

export type unregisterResponse = (unregisterResponseSuccess | unregisterResponseError)

export const getUnregisterUrl = () => {


  

  return `/unregister`
}

export const unregister = async (unregisterRequest: UnregisterRequest, options?: RequestInit): Promise<unregisterResponse> => {
  
  return customFetch<unregisterResponse>(getUnregisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      unregisterRequest,)
  }
);}
  


/**
 * Returns information about the agent itself and nearby entities within the specified radius.
 * @summary Observe the world around the agent
 */
export type observeResponse200 = {
  data: Observe200
  status: 200
}

export type observeResponse401 = {
  data: void
  status: 401
}

export type observeResponse404 = {
  data: void
  status: 404
}

export type observeResponseSuccess = (observeResponse200) & {
  headers: Headers;
};
export type observeResponseError = (observeResponse401 | observeResponse404) & {
  headers: Headers;
};

export type observeResponse = (observeResponseSuccess | observeResponseError)

export const getObserveUrl = () => {


  

  return `/observe`
}

export const observe = async (observeRequest: ObserveRequest, options?: RequestInit): Promise<observeResponse> => {
  
  return customFetch<observeResponse>(getObserveUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      observeRequest,)
  }
);}
  


/**
 * Initiates movement to the specified tile coordinates. Uses txId for idempotency.
 * @summary Move agent to a destination tile
 */
export type moveToResponse200 = {
  data: MoveTo200
  status: 200
}

export type moveToResponse400 = {
  data: void
  status: 400
}

export type moveToResponse401 = {
  data: void
  status: 401
}

export type moveToResponseSuccess = (moveToResponse200) & {
  headers: Headers;
};
export type moveToResponseError = (moveToResponse400 | moveToResponse401) & {
  headers: Headers;
};

export type moveToResponse = (moveToResponseSuccess | moveToResponseError)

export const getMoveToUrl = () => {


  

  return `/moveTo`
}

export const moveTo = async (moveToRequest: MoveToRequest, options?: RequestInit): Promise<moveToResponse> => {
  
  return customFetch<moveToResponse>(getMoveToUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moveToRequest,)
  }
);}
  


/**
 * Perform an action on a target entity (e.g., read a sign, use a terminal). Check affordances from observe response.
 * @summary Interact with a world object
 */
export type interactResponse200 = {
  data: Interact200
  status: 200
}

export type interactResponse400 = {
  data: void
  status: 400
}

export type interactResponse401 = {
  data: void
  status: 401
}

export type interactResponseSuccess = (interactResponse200) & {
  headers: Headers;
};
export type interactResponseError = (interactResponse400 | interactResponse401) & {
  headers: Headers;
};

export type interactResponse = (interactResponseSuccess | interactResponseError)

export const getInteractUrl = () => {


  

  return `/interact`
}

export const interact = async (interactRequest: InteractRequest, options?: RequestInit): Promise<interactResponse> => {
  
  return customFetch<interactResponse>(getInteractUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      interactRequest,)
  }
);}
  


/**
 * Send a message to the specified channel. Use "proximity" for nearby entities or "global" for the entire room.
 * @summary Send a chat message
 */
export type chatSendResponse200 = {
  data: ChatSend200
  status: 200
}

export type chatSendResponse401 = {
  data: void
  status: 401
}

export type chatSendResponse429 = {
  data: void
  status: 429
}

export type chatSendResponseSuccess = (chatSendResponse200) & {
  headers: Headers;
};
export type chatSendResponseError = (chatSendResponse401 | chatSendResponse429) & {
  headers: Headers;
};

export type chatSendResponse = (chatSendResponseSuccess | chatSendResponseError)

export const getChatSendUrl = () => {


  

  return `/chatSend`
}

export const chatSend = async (chatSendRequest: ChatSendRequest, options?: RequestInit): Promise<chatSendResponse> => {
  
  return customFetch<chatSendResponse>(getChatSendUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      chatSendRequest,)
  }
);}
  


/**
 * Retrieve chat messages from the specified time window.
 * @summary Get recent chat messages
 */
export type chatObserveResponse200 = {
  data: ChatObserve200
  status: 200
}

export type chatObserveResponse401 = {
  data: void
  status: 401
}

export type chatObserveResponseSuccess = (chatObserveResponse200) & {
  headers: Headers;
};
export type chatObserveResponseError = (chatObserveResponse401) & {
  headers: Headers;
};

export type chatObserveResponse = (chatObserveResponseSuccess | chatObserveResponseError)

export const getChatObserveUrl = () => {


  

  return `/chatObserve`
}

export const chatObserve = async (chatObserveRequest: ChatObserveRequest, options?: RequestInit): Promise<chatObserveResponse> => {
  
  return customFetch<chatObserveResponse>(getChatObserveUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      chatObserveRequest,)
  }
);}
  


/**
 * Long-poll for events since the given cursor. Returns immediately if events are available, or waits up to waitMs for new events.
 * @summary Poll for world events
 */
export type pollEventsResponse200 = {
  data: PollEvents200
  status: 200
}

export type pollEventsResponse401 = {
  data: void
  status: 401
}

export type pollEventsResponseSuccess = (pollEventsResponse200) & {
  headers: Headers;
};
export type pollEventsResponseError = (pollEventsResponse401) & {
  headers: Headers;
};

export type pollEventsResponse = (pollEventsResponseSuccess | pollEventsResponseError)

export const getPollEventsUrl = () => {


  

  return `/pollEvents`
}

export const pollEvents = async (pollEventsRequest: PollEventsRequest, options?: RequestInit): Promise<pollEventsResponse> => {
  
  return customFetch<pollEventsResponse>(getPollEventsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pollEventsRequest,)
  }
);}
  


/**
 * Update the agent name or metadata.
 * @summary Update agent profile
 */
export type profileUpdateResponse200 = {
  data: ProfileUpdate200
  status: 200
}

export type profileUpdateResponse401 = {
  data: void
  status: 401
}

export type profileUpdateResponseSuccess = (profileUpdateResponse200) & {
  headers: Headers;
};
export type profileUpdateResponseError = (profileUpdateResponse401) & {
  headers: Headers;
};

export type profileUpdateResponse = (profileUpdateResponseSuccess | profileUpdateResponseError)

export const getProfileUpdateUrl = () => {


  

  return `/profile/update`
}

export const profileUpdate = async (profileUpdateRequest: ProfileUpdateRequest, options?: RequestInit): Promise<profileUpdateResponse> => {
  
  return customFetch<profileUpdateResponse>(getProfileUpdateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      profileUpdateRequest,)
  }
);}
  


/**
 * Returns a list of skills available to the agent. Can filter by category or installed status.
 * @summary List available skills
 */
export type skillListResponse200 = {
  data: SkillList200
  status: 200
}

export type skillListResponse401 = {
  data: void
  status: 401
}

export type skillListResponse404 = {
  data: void
  status: 404
}

export type skillListResponseSuccess = (skillListResponse200) & {
  headers: Headers;
};
export type skillListResponseError = (skillListResponse401 | skillListResponse404) & {
  headers: Headers;
};

export type skillListResponse = (skillListResponseSuccess | skillListResponseError)

export const getSkillListUrl = () => {


  

  return `/skill/list`
}

export const skillList = async (skillListRequest: SkillListRequest, options?: RequestInit): Promise<skillListResponse> => {
  
  return customFetch<skillListResponse>(getSkillListUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      skillListRequest,)
  }
);}
  


/**
 * Installs a skill for the agent, making its actions available for use. Uses txId for idempotency.
 * @summary Install a skill for an agent
 */
export type skillInstallResponse200 = {
  data: SkillInstall200
  status: 200
}

export type skillInstallResponse400 = {
  data: void
  status: 400
}

export type skillInstallResponse401 = {
  data: void
  status: 401
}

export type skillInstallResponse404 = {
  data: void
  status: 404
}

export type skillInstallResponse503 = {
  data: void
  status: 503
}

export type skillInstallResponseSuccess = (skillInstallResponse200) & {
  headers: Headers;
};
export type skillInstallResponseError = (skillInstallResponse400 | skillInstallResponse401 | skillInstallResponse404 | skillInstallResponse503) & {
  headers: Headers;
};

export type skillInstallResponse = (skillInstallResponseSuccess | skillInstallResponseError)

export const getSkillInstallUrl = () => {


  

  return `/skill/install`
}

export const skillInstall = async (skillInstallRequest: SkillInstallRequest, options?: RequestInit): Promise<skillInstallResponse> => {
  
  return customFetch<skillInstallResponse>(getSkillInstallUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      skillInstallRequest,)
  }
);}
  


/**
 * Invokes an action from an installed skill. Subject to cooldown (5s default) and cast time (1s default). Uses txId for idempotency.
 * @summary Invoke a skill action
 */
export type skillInvokeResponse200 = {
  data: SkillInvoke200
  status: 200
}

export type skillInvokeResponse400 = {
  data: void
  status: 400
}

export type skillInvokeResponse401 = {
  data: void
  status: 401
}

export type skillInvokeResponse403 = {
  data: void
  status: 403
}

export type skillInvokeResponse404 = {
  data: void
  status: 404
}

export type skillInvokeResponse429 = {
  data: void
  status: 429
}

export type skillInvokeResponseSuccess = (skillInvokeResponse200) & {
  headers: Headers;
};
export type skillInvokeResponseError = (skillInvokeResponse400 | skillInvokeResponse401 | skillInvokeResponse403 | skillInvokeResponse404 | skillInvokeResponse429) & {
  headers: Headers;
};

export type skillInvokeResponse = (skillInvokeResponseSuccess | skillInvokeResponseError)

export const getSkillInvokeUrl = () => {


  

  return `/skill/invoke`
}

export const skillInvoke = async (skillInvokeRequest: SkillInvokeRequest, options?: RequestInit): Promise<skillInvokeResponse> => {
  
  return customFetch<skillInvokeResponse>(getSkillInvokeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      skillInvokeRequest,)
  }
);}
  


/**
 * Returns all available game channels/rooms that agents can join.
 * @summary List available channels
 */
export type channelsResponse200 = {
  data: Channels200
  status: 200
}

export type channelsResponseSuccess = (channelsResponse200) & {
  headers: Headers;
};
;

export type channelsResponse = (channelsResponseSuccess)

export const getChannelsUrl = () => {


  

  return `/channels`
}

export const channels = async ( options?: RequestInit): Promise<channelsResponse> => {
  
  return customFetch<channelsResponse>(getChannelsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  


/**
 * Allows an agent to reconnect using a previously issued session token.
 * @summary Reconnect an agent to an existing session
 */
export type reconnectResponse200 = {
  data: Reconnect200
  status: 200
}

export type reconnectResponse401 = {
  data: void
  status: 401
}

export type reconnectResponse404 = {
  data: void
  status: 404
}

export type reconnectResponseSuccess = (reconnectResponse200) & {
  headers: Headers;
};
export type reconnectResponseError = (reconnectResponse401 | reconnectResponse404) & {
  headers: Headers;
};

export type reconnectResponse = (reconnectResponseSuccess | reconnectResponseError)

export const getReconnectUrl = () => {


  

  return `/reconnect`
}

export const reconnect = async (reconnectRequest: ReconnectRequest, options?: RequestInit): Promise<reconnectResponse> => {
  
  return customFetch<reconnectResponse>(getReconnectUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      reconnectRequest,)
  }
);}
  


/**
 * Keeps the agent session alive and returns server timing information.
 * @summary Send a heartbeat to maintain session
 */
export type heartbeatResponse200 = {
  data: Heartbeat200
  status: 200
}

export type heartbeatResponse401 = {
  data: void
  status: 401
}

export type heartbeatResponse404 = {
  data: void
  status: 404
}

export type heartbeatResponseSuccess = (heartbeatResponse200) & {
  headers: Headers;
};
export type heartbeatResponseError = (heartbeatResponse401 | heartbeatResponse404) & {
  headers: Headers;
};

export type heartbeatResponse = (heartbeatResponseSuccess | heartbeatResponseError)

export const getHeartbeatUrl = () => {


  

  return `/heartbeat`
}

export const heartbeat = async (heartbeatRequest: HeartbeatRequest, options?: RequestInit): Promise<heartbeatResponse> => {
  
  return customFetch<heartbeatResponse>(getHeartbeatUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      heartbeatRequest,)
  }
);}
  


/**
 * Returns all active meetings in the specified room.
 * @summary List available meetings in the room
 */
export type meetingListResponse200 = {
  data: MeetingList200
  status: 200
}

export type meetingListResponse401 = {
  data: void
  status: 401
}

export type meetingListResponseSuccess = (meetingListResponse200) & {
  headers: Headers;
};
export type meetingListResponseError = (meetingListResponse401) & {
  headers: Headers;
};

export type meetingListResponse = (meetingListResponseSuccess | meetingListResponseError)

export const getMeetingListUrl = () => {


  

  return `/meeting/list`
}

export const meetingList = async (meetingListRequest: MeetingListRequest, options?: RequestInit): Promise<meetingListResponse> => {
  
  return customFetch<meetingListResponse>(getMeetingListUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meetingListRequest,)
  }
);}
  


/**
 * Joins the specified meeting as a participant or host.
 * @summary Join a meeting
 */
export type meetingJoinResponse200 = {
  data: MeetingJoin200
  status: 200
}

export type meetingJoinResponse401 = {
  data: void
  status: 401
}

export type meetingJoinResponse404 = {
  data: void
  status: 404
}

export type meetingJoinResponse409 = {
  data: void
  status: 409
}

export type meetingJoinResponseSuccess = (meetingJoinResponse200) & {
  headers: Headers;
};
export type meetingJoinResponseError = (meetingJoinResponse401 | meetingJoinResponse404 | meetingJoinResponse409) & {
  headers: Headers;
};

export type meetingJoinResponse = (meetingJoinResponseSuccess | meetingJoinResponseError)

export const getMeetingJoinUrl = () => {


  

  return `/meeting/join`
}

export const meetingJoin = async (meetingJoinRequest: MeetingJoinRequest, options?: RequestInit): Promise<meetingJoinResponse> => {
  
  return customFetch<meetingJoinResponse>(getMeetingJoinUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meetingJoinRequest,)
  }
);}
  


/**
 * Leaves the specified meeting.
 * @summary Leave a meeting
 */
export type meetingLeaveResponse200 = {
  data: MeetingLeave200
  status: 200
}

export type meetingLeaveResponse401 = {
  data: void
  status: 401
}

export type meetingLeaveResponse404 = {
  data: void
  status: 404
}

export type meetingLeaveResponseSuccess = (meetingLeaveResponse200) & {
  headers: Headers;
};
export type meetingLeaveResponseError = (meetingLeaveResponse401 | meetingLeaveResponse404) & {
  headers: Headers;
};

export type meetingLeaveResponse = (meetingLeaveResponseSuccess | meetingLeaveResponseError)

export const getMeetingLeaveUrl = () => {


  

  return `/meeting/leave`
}

export const meetingLeave = async (meetingLeaveRequest: MeetingLeaveRequest, options?: RequestInit): Promise<meetingLeaveResponse> => {
  
  return customFetch<meetingLeaveResponse>(getMeetingLeaveUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meetingLeaveRequest,)
  }
);}
